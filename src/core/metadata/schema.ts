import { z } from 'zod';
import { TIERS, type Tier } from '../domains/classifier.js';

/**
 * 22-field metadata schema for documentation files.
 * This schema validates the YAML frontmatter of documentation files.
 */

// Core Identity Fields (Required)
const coreIdentitySchema = z.object({
  title: z.string().min(1, 'Title is required'),
  tier: z.enum(TIERS as unknown as [Tier, ...Tier[]]),
  domains: z.array(z.string()).min(1, 'At least one domain is required'),
  audience: z.array(z.enum(['all', 'developers', 'devops', 'admin'])).default(['all']),
  tags: z.array(z.string()).default([]),
});

// Status & Lifecycle Fields (Required)
const statusSchema = z.object({
  status: z.enum(['draft', 'active', 'deprecated', 'archived']),
  last_updated: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Must be YYYY-MM-DD format'),
  version: z.string().regex(/^\d+\.\d+\.\d+$/, 'Must be semver format (X.Y.Z)'),
});

// Discovery & Navigation Fields (Optional)
const discoverySchema = z.object({
  purpose: z.string().optional(),
  related_docs: z.array(z.string()).optional(),
  load_priority: z.number().min(1).max(10).optional(),
});

// Ownership & Maintenance Fields (Optional)
const ownershipSchema = z.object({
  author: z.string().optional(),
  maintainer: z.string().optional(),
  review_frequency: z.enum(['weekly', 'monthly', 'quarterly', 'annually']).optional(),
});

// Implementation Fields (Optional)
const implementationSchema = z.object({
  implementation_status: z.enum(['planned', 'in_progress', 'complete', 'deprecated']).optional(),
  tested: z.boolean().optional(),
  production_ready: z.boolean().optional(),
});

// Auto-generated Fields
const autoGeneratedSchema = z.object({
  estimated_read_time: z.string().optional(),
  word_count: z.number().optional(),
  last_validated: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  backlinks: z.array(z.string()).optional(),
});

/**
 * Complete 22-field metadata schema
 */
export const MetadataSchema = coreIdentitySchema
  .merge(statusSchema)
  .merge(discoverySchema)
  .merge(ownershipSchema)
  .merge(implementationSchema)
  .merge(autoGeneratedSchema);

export type DocumentMetadata = z.infer<typeof MetadataSchema>;

/**
 * Partial schema for documents that may have incomplete metadata
 */
export const PartialMetadataSchema = MetadataSchema.partial();
export type PartialDocumentMetadata = z.infer<typeof PartialMetadataSchema>;

/**
 * Required fields that must always be present
 */
export const REQUIRED_FIELDS = [
  'title',
  'tier',
  'domains',
  'status',
  'last_updated',
  'version',
] as const;

/**
 * Optional fields with their default values
 */
export const OPTIONAL_FIELDS_DEFAULTS: Partial<DocumentMetadata> = {
  audience: ['all'],
  tags: [],
  backlinks: [],
};

/**
 * Auto-generated fields that should not be manually edited
 */
export const AUTO_GENERATED_FIELDS = [
  'estimated_read_time',
  'word_count',
  'last_validated',
  'backlinks',
] as const;

/**
 * All 22 field names
 */
export const ALL_METADATA_FIELDS = [
  // Core Identity (5)
  'title',
  'tier',
  'domains',
  'audience',
  'tags',
  // Status & Lifecycle (3)
  'status',
  'last_updated',
  'version',
  // Discovery & Navigation (3)
  'purpose',
  'related_docs',
  'load_priority',
  // Ownership & Maintenance (3)
  'author',
  'maintainer',
  'review_frequency',
  // Implementation (3)
  'implementation_status',
  'tested',
  'production_ready',
  // Auto-generated (4)
  'estimated_read_time',
  'word_count',
  'last_validated',
  'backlinks',
] as const;

export type MetadataField = (typeof ALL_METADATA_FIELDS)[number];

/**
 * Validate metadata against the schema
 */
export function validateMetadata(data: unknown): {
  valid: boolean;
  errors: string[];
  data?: DocumentMetadata;
} {
  const result = MetadataSchema.safeParse(data);

  if (result.success) {
    return { valid: true, errors: [], data: result.data };
  }

  const errors = result.error.errors.map(
    (e) => `${e.path.join('.')}: ${e.message}`
  );

  return { valid: false, errors };
}

/**
 * Validate partial metadata (for documents being fixed)
 */
export function validatePartialMetadata(data: unknown): {
  valid: boolean;
  errors: string[];
  data?: PartialDocumentMetadata;
} {
  const result = PartialMetadataSchema.safeParse(data);

  if (result.success) {
    return { valid: true, errors: [], data: result.data };
  }

  const errors = result.error.errors.map(
    (e) => `${e.path.join('.')}: ${e.message}`
  );

  return { valid: false, errors };
}

/**
 * Get missing required fields
 */
export function getMissingRequiredFields(
  data: Record<string, unknown>
): string[] {
  return REQUIRED_FIELDS.filter(
    (field) => !(field in data) || data[field] === undefined || data[field] === null
  );
}

/**
 * Get all missing fields (both required and optional)
 */
export function getMissingFields(
  data: Record<string, unknown>
): { required: string[]; optional: string[] } {
  const required = REQUIRED_FIELDS.filter(
    (field) => !(field in data) || data[field] === undefined
  );

  const optional = ALL_METADATA_FIELDS.filter(
    (field) =>
      !REQUIRED_FIELDS.includes(field as typeof REQUIRED_FIELDS[number]) &&
      !(field in data)
  );

  return { required, optional };
}

/**
 * Calculate metadata completeness percentage
 */
export function calculateMetadataCompleteness(
  data: Record<string, unknown>
): number {
  const presentFields = ALL_METADATA_FIELDS.filter(
    (field) => field in data && data[field] !== undefined && data[field] !== null
  );

  return (presentFields.length / ALL_METADATA_FIELDS.length) * 100;
}

/**
 * Get field category
 */
export function getFieldCategory(
  field: MetadataField
): 'core' | 'status' | 'discovery' | 'ownership' | 'implementation' | 'auto' {
  if (['title', 'tier', 'domains', 'audience', 'tags'].includes(field)) {
    return 'core';
  }
  if (['status', 'last_updated', 'version'].includes(field)) {
    return 'status';
  }
  if (['purpose', 'related_docs', 'load_priority'].includes(field)) {
    return 'discovery';
  }
  if (['author', 'maintainer', 'review_frequency'].includes(field)) {
    return 'ownership';
  }
  if (['implementation_status', 'tested', 'production_ready'].includes(field)) {
    return 'implementation';
  }
  return 'auto';
}
