import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { pathExists } from '../utils/glob.js';
import { formatDate } from '../core/metadata/generator.js';
import type { AuditResult } from '../core/audit/auditor.js';

export interface AuditReportOptions {
  docsPath: string;
  result: AuditResult;
  format?: 'markdown' | 'json';
}

/**
 * Generate an audit report
 */
export async function generateAuditReport(
  options: AuditReportOptions
): Promise<string> {
  const { result, format = 'markdown' } = options;

  if (format === 'json') {
    return generateJsonReport(result);
  }

  return generateMarkdownReport(result);
}

/**
 * Generate markdown audit report
 */
function generateMarkdownReport(result: AuditResult): string {
  const now = formatDate(new Date());
  const timestamp = new Date().toISOString();

  const errorIssues = result.issues.filter((i) => i.severity === 'error');
  const warningIssues = result.issues.filter((i) => i.severity === 'warning');
  const infoIssues = result.issues.filter((i) => i.severity === 'info');

  let content = `---
title: Documentation Audit Report
tier: admin
domains: [root]
status: active
last_updated: '${now}'
version: '1.0.0'
---

# Documentation Audit Report

**Generated:** ${timestamp}
**Health Score:** ${result.healthScore.toFixed(1)}/100

## Summary

| Metric | Value |
|--------|-------|
| Total Files | ${result.totalFiles} |
| Passed | ${result.passedFiles} |
| Failed | ${result.failedFiles} |
| Errors | ${errorIssues.length} |
| Warnings | ${warningIssues.length} |
| Info | ${infoIssues.length} |

## Compliance Scores

| Category | Score |
|----------|-------|
| Metadata Compliance | ${result.stats.metadataCompliance.toFixed(1)}% |
| Naming Compliance | ${result.stats.namingCompliance.toFixed(1)}% |
| Placement Compliance | ${result.stats.placementCompliance.toFixed(1)}% |
| Tag Consistency | ${result.stats.tagConsistency.toFixed(1)}% |

`;

  // Domain breakdown
  if (Object.keys(result.stats.byDomain).length > 0) {
    content += `## By Domain

| Domain | Files | Issues | Health |
|--------|-------|--------|--------|
`;
    for (const [domain, stats] of Object.entries(result.stats.byDomain)) {
      content += `| ${domain} | ${stats.files} | ${stats.issues} | ${stats.healthScore.toFixed(0)}% |\n`;
    }
    content += '\n';
  }

  // Critical Issues
  if (errorIssues.length > 0) {
    content += `## Critical Issues (${errorIssues.length})

| File | Rule | Message |
|------|------|---------|
`;
    for (const issue of errorIssues) {
      content += `| ${issue.file} | ${issue.rule} | ${issue.message} |\n`;
    }
    content += '\n';
  }

  // Warnings
  if (warningIssues.length > 0) {
    content += `## Warnings (${warningIssues.length})

| File | Rule | Message |
|------|------|---------|
`;
    for (const issue of warningIssues.slice(0, 20)) {
      content += `| ${issue.file} | ${issue.rule} | ${issue.message} |\n`;
    }
    if (warningIssues.length > 20) {
      content += `\n*...and ${warningIssues.length - 20} more warnings*\n`;
    }
    content += '\n';
  }

  // Fixable Issues
  const fixableIssues = result.issues.filter((i) => i.fixable);
  if (fixableIssues.length > 0) {
    content += `## Fixable Issues

${fixableIssues.length} issues can be auto-fixed. Run:

\`\`\`bash
npx hit-em-with-the-docs maintain --fix
\`\`\`

`;
  }

  content += `---

*Generated by hit-em-with-the-docs*
`;

  return content;
}

/**
 * Generate JSON audit report
 */
function generateJsonReport(result: AuditResult): string {
  return JSON.stringify({
    timestamp: new Date().toISOString(),
    healthScore: result.healthScore,
    summary: {
      totalFiles: result.totalFiles,
      passedFiles: result.passedFiles,
      failedFiles: result.failedFiles,
      totalIssues: result.issues.length,
    },
    stats: result.stats,
    issues: result.issues,
  }, null, 2);
}

/**
 * Save audit report to file
 */
export async function saveAuditReport(
  docsPath: string,
  result: AuditResult,
  format: 'markdown' | 'json' = 'markdown'
): Promise<string> {
  const reportsDir = join(docsPath, 'reports');

  if (!(await pathExists(reportsDir))) {
    await mkdir(reportsDir, { recursive: true });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  const ext = format === 'json' ? 'json' : 'md';
  const fileName = `audit-${timestamp}.${ext}`;
  const filePath = join(reportsDir, fileName);

  const content = await generateAuditReport({ docsPath, result, format });
  await writeFile(filePath, content, 'utf-8');

  return filePath;
}
