import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { pathExists } from '../utils/glob.js';
import { formatDate } from '../core/metadata/generator.js';
import type { LinkCheckResult } from '../core/links/checker.js';

export interface LinkReportOptions {
  docsPath: string;
  result: LinkCheckResult;
  format?: 'markdown' | 'json';
}

/**
 * Generate a link report
 */
export async function generateLinkReport(
  options: LinkReportOptions
): Promise<string> {
  const { result, format = 'markdown' } = options;

  if (format === 'json') {
    return generateJsonReport(result);
  }

  return generateMarkdownReport(result);
}

/**
 * Generate markdown link report
 */
function generateMarkdownReport(result: LinkCheckResult): string {
  const now = formatDate(new Date());
  const timestamp = new Date().toISOString();

  let content = `---
title: Link Check Report
tier: admin
domains: [root]
status: active
last_updated: '${now}'
version: '1.0.0'
---

# Link Check Report

**Generated:** ${timestamp}

## Summary

| Metric | Value |
|--------|-------|
| Files Checked | ${result.totalFiles} |
| Total Links | ${result.totalLinks} |
| Valid Links | ${result.validLinks} |
| Broken Links | ${result.brokenLinks.length} |
| Internal Links | ${result.stats.internalLinks} |
| External Links | ${result.stats.externalLinks} |
| Cross-Domain Links | ${result.stats.crossDomainLinks} |

## Link Health

\`\`\`
Total Links: ${result.totalLinks}
├── Valid: ${result.validLinks} (${((result.validLinks / result.totalLinks) * 100).toFixed(1)}%)
├── Broken: ${result.brokenLinks.length} (${result.stats.brokenPercentage.toFixed(1)}%)
└── Cross-Domain: ${result.stats.crossDomainLinks} (${((result.stats.crossDomainLinks / result.totalLinks) * 100).toFixed(1)}%)
\`\`\`

`;

  // Broken Links
  if (result.brokenLinks.length > 0) {
    content += `## Broken Links (${result.brokenLinks.length})

| Source File | Line | Target | Link Text |
|-------------|------|--------|-----------|
`;
    for (const link of result.brokenLinks) {
      content += `| ${link.sourceFile} | ${link.lineNumber} | \`${link.targetPath}\` | ${link.linkText.slice(0, 30)} |\n`;
    }
    content += '\n';
  } else {
    content += `## Broken Links

✅ No broken links found!

`;
  }

  // Top Cross-Domain Connections
  if (result.stats.topConnectedDomains.length > 0) {
    content += `## Cross-Domain Connections

| From | To | Links |
|------|-----|-------|
`;
    for (const conn of result.stats.topConnectedDomains) {
      content += `| ${conn.from} | ${conn.to} | ${conn.count} |\n`;
    }
    content += '\n';
  }

  // Cross-Domain Links Details
  if (result.crossDomainLinks.length > 0) {
    content += `## Cross-Domain Link Details

<details>
<summary>Show all ${result.crossDomainLinks.length} cross-domain links</summary>

| Source | From Domain | Target Domain | Link |
|--------|-------------|---------------|------|
`;
    for (const link of result.crossDomainLinks.slice(0, 50)) {
      content += `| ${link.sourceFile} | ${link.sourceDomain} | ${link.targetDomain} | ${link.linkText.slice(0, 30)} |\n`;
    }
    if (result.crossDomainLinks.length > 50) {
      content += `\n*...and ${result.crossDomainLinks.length - 50} more*\n`;
    }
    content += '\n</details>\n\n';
  }

  // External Links
  if (result.externalLinks.length > 0) {
    content += `## External Links (${result.externalLinks.length})

<details>
<summary>Show external links</summary>

| Source File | URL |
|-------------|-----|
`;
    for (const link of result.externalLinks.slice(0, 30)) {
      content += `| ${link.sourceFile} | ${link.url.slice(0, 50)}${link.url.length > 50 ? '...' : ''} |\n`;
    }
    if (result.externalLinks.length > 30) {
      content += `\n*...and ${result.externalLinks.length - 30} more*\n`;
    }
    content += '\n</details>\n\n';
  }

  content += `---

*Generated by hit-em-with-the-docs*
`;

  return content;
}

/**
 * Generate JSON link report
 */
function generateJsonReport(result: LinkCheckResult): string {
  return JSON.stringify({
    timestamp: new Date().toISOString(),
    summary: {
      totalFiles: result.totalFiles,
      totalLinks: result.totalLinks,
      validLinks: result.validLinks,
      brokenLinks: result.brokenLinks.length,
      externalLinks: result.externalLinks.length,
      crossDomainLinks: result.crossDomainLinks.length,
    },
    stats: result.stats,
    brokenLinks: result.brokenLinks,
    crossDomainLinks: result.crossDomainLinks,
    externalLinks: result.externalLinks,
  }, null, 2);
}

/**
 * Save link report to file
 */
export async function saveLinkReport(
  docsPath: string,
  result: LinkCheckResult,
  format: 'markdown' | 'json' = 'markdown'
): Promise<string> {
  const reportsDir = join(docsPath, 'reports');

  if (!(await pathExists(reportsDir))) {
    await mkdir(reportsDir, { recursive: true });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  const ext = format === 'json' ? 'json' : 'md';
  const fileName = `links-${timestamp}.${ext}`;
  const filePath = join(reportsDir, fileName);

  const content = await generateLinkReport({ docsPath, result, format });
  await writeFile(filePath, content, 'utf-8');

  return filePath;
}
