import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { pathExists } from '../utils/glob.js';
import { formatDate } from '../core/metadata/generator.js';
import type { MaintainResult } from '../core/maintain/orchestrator.js';

export interface HealthReportOptions {
  docsPath: string;
  result: MaintainResult;
  format?: 'markdown' | 'json';
}

/**
 * Generate a health report
 */
export async function generateHealthReport(
  options: HealthReportOptions
): Promise<string> {
  const { result, format = 'markdown' } = options;

  if (format === 'json') {
    return generateJsonReport(result);
  }

  return generateMarkdownReport(result);
}

/**
 * Generate markdown health report
 */
function generateMarkdownReport(result: MaintainResult): string {
  const now = formatDate(new Date());
  const timestamp = new Date().toISOString();

  return `---
title: Documentation Health Report
tier: admin
domains: [root]
status: active
last_updated: '${now}'
version: '1.0.0'
---

# Documentation Health Report

**Generated:** ${timestamp}
**Health Score:** ${result.healthScore.toFixed(1)}/100

## Summary

| Metric | Value | Status |
|--------|-------|--------|
| Health Score | ${result.healthScore.toFixed(1)}% | ${getStatusEmoji(result.healthScore)} |
| Domain Health | ${result.domainHealth.healthy ? 'Healthy' : 'Issues'} | ${result.domainHealth.healthy ? 'âœ…' : 'âš ï¸'} |
| Files Analyzed | ${result.metadataSync?.totalFiles ?? 0} | â„¹ï¸ |
| Valid Files | ${result.metadataSync?.validFiles ?? 0} | ${getStatusEmoji((result.metadataSync?.validFiles ?? 0) / (result.metadataSync?.totalFiles ?? 1) * 100)} |
| Broken Links | ${result.linkCheck?.brokenLinks.length ?? 'N/A'} | ${(result.linkCheck?.brokenLinks.length ?? 0) === 0 ? 'âœ…' : 'âš ï¸'} |

## Health Score Breakdown

\`\`\`
Overall Score: ${result.healthScore.toFixed(1)}/100

Components:
â”œâ”€â”€ Domain Health: ${result.domainHealth.healthy ? '100' : '50'}/100 (weight: 20%)
â”œâ”€â”€ Metadata Compliance: ${result.audit?.stats.metadataCompliance.toFixed(1) ?? 'N/A'}/100 (weight: 40%)
â”œâ”€â”€ Link Health: ${result.linkCheck ? (100 - result.linkCheck.stats.brokenPercentage).toFixed(1) : 'N/A'}/100 (weight: 20%)
â””â”€â”€ Naming Compliance: ${result.audit?.stats.namingCompliance.toFixed(1) ?? 'N/A'}/100 (weight: 20%)
\`\`\`

## Recommendations

${generateRecommendations(result)}

---

*Generated by hit-em-with-the-docs*
`;
}

/**
 * Generate JSON health report
 */
function generateJsonReport(result: MaintainResult): string {
  return JSON.stringify({
    timestamp: new Date().toISOString(),
    healthScore: result.healthScore,
    summary: {
      domainHealth: result.domainHealth.healthy,
      totalFiles: result.metadataSync?.totalFiles ?? 0,
      validFiles: result.metadataSync?.validFiles ?? 0,
      brokenLinks: result.linkCheck?.brokenLinks.length ?? null,
      auditIssues: result.audit?.issues.length ?? 0,
    },
    domainHealth: result.domainHealth,
    metadataSync: result.metadataSync ? {
      totalFiles: result.metadataSync.totalFiles,
      validFiles: result.metadataSync.validFiles,
      fixedFiles: result.metadataSync.fixedFiles,
      avgCompleteness: result.metadataSync.stats.avgCompleteness,
    } : null,
    linkCheck: result.linkCheck ? {
      totalLinks: result.linkCheck.totalLinks,
      brokenLinks: result.linkCheck.brokenLinks.length,
      crossDomainLinks: result.linkCheck.stats.crossDomainLinks,
    } : null,
    audit: result.audit ? {
      passedFiles: result.audit.passedFiles,
      failedFiles: result.audit.failedFiles,
      healthScore: result.audit.healthScore,
      stats: result.audit.stats,
    } : null,
    errors: result.errors,
  }, null, 2);
}

/**
 * Get status emoji based on score
 */
function getStatusEmoji(score: number): string {
  if (score >= 90) return 'âœ…';
  if (score >= 70) return 'ðŸŸ¡';
  if (score >= 50) return 'âš ï¸';
  return 'âŒ';
}

/**
 * Generate recommendations based on results
 */
function generateRecommendations(result: MaintainResult): string {
  const recommendations: string[] = [];

  // Domain health recommendations
  if (!result.domainHealth.healthy) {
    if (result.domainHealth.missingDomains.length > 0) {
      recommendations.push(`- **Create missing domain folders:** ${result.domainHealth.missingDomains.join(', ')}`);
    }
    if (result.domainHealth.missingIndexes.length > 0) {
      recommendations.push(`- **Create missing INDEX.md files:** ${result.domainHealth.missingIndexes.join(', ')}`);
    }
    if (result.domainHealth.missingRegistries.length > 0) {
      recommendations.push(`- **Create missing REGISTRY.md files:** ${result.domainHealth.missingRegistries.join(', ')}`);
    }
  }

  // Metadata recommendations
  if (result.metadataSync) {
    const invalidFiles = result.metadataSync.totalFiles - result.metadataSync.validFiles;
    if (invalidFiles > 0) {
      recommendations.push(`- **Fix metadata in ${invalidFiles} files:** Run \`npx hit-em-with-the-docs metadata-sync --fix\``);
    }
    if (result.metadataSync.stats.avgCompleteness < 80) {
      recommendations.push(`- **Improve metadata completeness:** Current average is ${result.metadataSync.stats.avgCompleteness.toFixed(1)}%`);
    }
  }

  // Link recommendations
  if (result.linkCheck && result.linkCheck.brokenLinks.length > 0) {
    recommendations.push(`- **Fix ${result.linkCheck.brokenLinks.length} broken links:** Run \`npx hit-em-with-the-docs link-check --report\` for details`);
  }

  // Audit recommendations
  if (result.audit) {
    const errors = result.audit.issues.filter((i) => i.severity === 'error');
    if (errors.length > 0) {
      recommendations.push(`- **Address ${errors.length} critical audit issues:** Run \`npx hit-em-with-the-docs audit --issues-only\``);
    }
    if (result.audit.stats.namingCompliance < 90) {
      recommendations.push(`- **Improve naming convention compliance:** Rename files to use kebab-case`);
    }
  }

  if (recommendations.length === 0) {
    return 'âœ… No recommendations - documentation is in great shape!';
  }

  return recommendations.join('\n');
}

/**
 * Save health report to file
 */
export async function saveHealthReport(
  docsPath: string,
  result: MaintainResult,
  format: 'markdown' | 'json' = 'markdown'
): Promise<string> {
  const reportsDir = join(docsPath, 'reports');

  if (!(await pathExists(reportsDir))) {
    await mkdir(reportsDir, { recursive: true });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  const ext = format === 'json' ? 'json' : 'md';
  const fileName = `health-${timestamp}.${ext}`;
  const filePath = join(reportsDir, fileName);

  const content = await generateHealthReport({ docsPath, result, format });
  await writeFile(filePath, content, 'utf-8');

  return filePath;
}
